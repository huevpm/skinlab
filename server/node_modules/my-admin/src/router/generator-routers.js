// eslint-disable-next-line
import { BasicLayout, BlankLayout, PageView, RouteView } from '#/layouts'
import Vue from 'vue'
import md5 from 'md5';

// 前端路由表
const constantRouterComponents = {
    // 基础页面 layout 必须引入
    BasicLayout: BasicLayout,
    BlankLayout: BlankLayout,
    RouteView: RouteView,
    PageView: PageView,
    'Menus': () => import('#/views/system/Menus'),
    'Roles': () => import('#/views/system/Roles'),
    'Rules': () => import('#/views/system/Rules'),
    'Users': () => import('#/views/system/Users'),
    'Perms': () => import('#/views/system/Perms'),
    'Center': () => import('#/views/system/Center'),
    'Settings': () => import('#/views/system/Settings'),
    'Messages': () => import('#/views/system/Messages'),
    '403': () => import( /* webpackChunkName: "error" */ '#/views/exception/403'),
    '404': () => import( /* webpackChunkName: "error" */ '#/views/exception/404'),
    '500': () => import( /* webpackChunkName: "error" */ '#/views/exception/500'),
    // exception
    'Exception403': () => import( /* webpackChunkName: "fail" */ '#/views/exception/403'),
    'Exception404': () => import( /* webpackChunkName: "fail" */ '#/views/exception/404'),
    'Exception500': () => import( /* webpackChunkName: "fail" */ '#/views/exception/500')
}

//通过WebPack context 加载文件
const componentsFiles = require.context('@/views', true, /\.vue$/)

const components = componentsFiles.keys().reduce((components, componentPath) => {
    // set './app.js' => 'app'
    const componentName = componentPath.replace(/^\.\/(.*)\.\w+$/, '$1')
    const value = componentsFiles(componentPath)
    //必须MD5加密 否则无法找到
    components[md5("/" + componentName)] = value.default
    return components
}, {})


// 前端未找到页面路由（固定不用改）
const notFoundRouter = {
    path: '*',
    redirect: '/404',
    hidden: true
}

// 根级菜单
const rootRouter = {
    key: '',
    name: 'index',
    path: '/admin',
    component: 'BasicLayout',
    redirect: '/dashboard/works',
    meta: {
        title: '首页'
    },
    children: []
}

/**
 * 动态生成菜单
 * @param token
 * @returns {Promise<Router>}
 */
export const generatorDynamicRouter = ($cloud, token) => {
    return new Promise(async (resolve, reject) => {
        $cloud.menus().get().then(res => {
            //配置信息
            let config = {
                parentKey: "parentId",
                idKey: "menuId",
                parentId: 0,
                childrenKey: "children"
            }

            //执行递归嵌套子集
            let childrenNav = $cloud
                .tree(config)
                .field("path", (value, self, parent) => {
                    if (Object.keys(parent).length === 0) {
                        return "/" + self['name'];
                    } else {
                        return parent['path'] + "/" + self['name'];
                    }
                })
                .field("meta", (value, self, parent) => {
                    let permission = [];
                    if (self.type == 'PAGE') {
                        permission = [self.name]
                    }
                    return {
                        "title": self['title'],
                        "icon": self['icon'],
                        "show": self['show'],
                        "hideChildren":self['hideChildren'],
                        "permission": permission
                    }
                })
                .add("meta", "")
                .add("meta", "")
                .del("_id").del("icon").del("title").del("show").del("rules")
                .on(res).get();

            //综合处理
            const menuNav = []
            rootRouter.children = childrenNav
            menuNav.push(rootRouter)
            //console.log('menuNav', menuNav)
            const routers = generator(menuNav)
            routers.push(notFoundRouter)
            //console.log('routers', routers)
            resolve(routers)
        }).catch(err => {
            reject(err)
        })
    })
}

/**
 * 格式化树形结构数据 生成 vue-router 层级路由表
 *
 * @param routerMap
 * @param parent
 * @returns {*}
 */
export const generator = (routerMap, parent) => {
    return routerMap.map(item => {
        const { title, show, hideChildren, permission, hiddenHeaderContent, target, icon } = item.meta || {}
        // console.log("读取", `@/views${item.path}`)
        const currentRouter = {
            // 如果路由设置了 path，则作为默认 path，否则 路由地址 动态拼接生成如 /dashboard/workplace
            path: item.path || `${parent && parent.path || ''}/${item.key}`,
            // 路由名称，建议唯一
            name: item.name || item.key || '',
            // 该路由对应页面的 组件 :方案1
            // component: constantRouterComponents[item.component || item.key],
            // 该路由对应页面的 组件 :方案2 (动态加载)
            component: (constantRouterComponents[item.component || item.key]) || components[md5(item.path)],
            // (() => import(`#/views${item.path}`))
            // components[item.path]
            // meta: 页面标题, 菜单图标, 页面权限(供指令权限用，可去掉)
            meta: {
                title: title,
                icon: icon || undefined,
                hiddenHeaderContent: hiddenHeaderContent,
                target: target,
                permission: permission || item.name
            }
        }

        //判断是否有子集
        if (item.children) {
            currentRouter.redirect = item.children[0].path;
        }

        // 是否设置了隐藏菜单
        if (!show) {
            currentRouter.hidden = true
        }

        // 是否设置了隐藏子菜单
        if (hideChildren) {
            currentRouter.hideChildrenInMenu = true
        }

        // 为了防止出现后端返回结果不规范，处理有可能出现拼接出两个 反斜杠
        if (!currentRouter.path.startsWith('http')) {
            currentRouter.path = currentRouter.path.replace('//', '/')
        }
        // 重定向
        item.redirect && (currentRouter.redirect = item.redirect)
        // 是否有子菜单，并递归处理
        if (item.children && item.children.length > 0) {
            // Recursion
            currentRouter.children = generator(item.children, currentRouter)
        }
        return currentRouter
    })
}

/**
 * 数组转树形结构
 * @param list 源数组
 * @param tree 树
 * @param parentId 父ID
 */
const listToTree = (list, tree, parentId) => {
    list.forEach(item => {
        // 判断是否为父级菜单
        if (item.parentId === parentId) {
            const child = {
                ...item,
                key: item.key || item.name,
                children: []
            }
            // 迭代 list， 找到当前菜单相符合的所有子菜单
            listToTree(list, child.children, item.id)
            // 删掉不存在 children 值的属性
            if (child.children.length <= 0) {
                delete child.children
            }
            // 加入到树中
            tree.push(child)
        }
    })
}