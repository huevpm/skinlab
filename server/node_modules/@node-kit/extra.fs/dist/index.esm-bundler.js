import { existsSync, readFileSync, promises, writeFileSync, realpathSync, realpath, mkdirSync, lstatSync, copyFileSync, constants, readdirSync, unlinkSync, rmdirSync } from 'fs';
import { join, basename, isAbsolute } from 'path';

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function readJSON() {
  return _readJSON.apply(this, arguments);
}
function _readJSON() {
  _readJSON = _asyncToGenerator(function* () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (!existsSync(args[0]))
      return null;
    var data = yield promises.readFile.apply(promises, args).toString();
    try {
      return JSON.parse(data);
    } catch (_unused2) {
      return null;
    }
  });
  return _readJSON.apply(this, arguments);
}
function readJSONSync() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (!existsSync(args[0]))
    return null;
  var data = readFileSync.apply(void 0, args).toString();
  try {
    return JSON.parse(data);
  } catch (_unused) {
    return {};
  }
}

function writeJSON(_x, _x2, _x3) {
  return _writeJSON.apply(this, arguments);
}
function _writeJSON() {
  _writeJSON = _asyncToGenerator(function* (file, data, options) {
    if (_typeof(data) === "object") {
      data = data && JSON.stringify(data, null, 4) || "";
    }
    yield promises.writeFile(file, data, options);
  });
  return _writeJSON.apply(this, arguments);
}
function writeJSONSync(file, data, options) {
  if (_typeof(data) === "object") {
    data = data && JSON.stringify(data, null, 4) || "";
  }
  writeFileSync(file, data, options);
}

function getRealPath(_x) {
  return _getRealPath.apply(this, arguments);
}
function _getRealPath() {
  _getRealPath = _asyncToGenerator(function* (path) {
    return new Promise(function(resolve) {
      realpath.native(path, function(err, resolvedPath) {
        resolve(err !== null ? path : resolvedPath);
      });
    });
  });
  return _getRealPath.apply(this, arguments);
}
function getRealPathSync(path) {
  return realpathSync.native(path);
}

var __knownSymbol$1 = (name, symbol) => {
  if (symbol = Symbol[name])
    return symbol;
  throw Error("Symbol." + name + " is not defined");
};
var __await$1 = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar$1 = (value) => {
  var obj = value[__knownSymbol$1("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol$1("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await$1(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol$1("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
function cp(_x, _x2) {
  return _cp.apply(this, arguments);
}
function _cp() {
  _cp = _asyncToGenerator(function* (paths, target) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      silent: true,
      force: true
    };
    if (!(paths instanceof Array))
      paths = [].concat(paths);
    if (!existsSync(target))
      yield promises.mkdir(target);
    var _iterator3 = _createForOfIteratorHelper(paths), _step3;
    try {
      var _loop = function* _loop2() {
        var path = _step3.value;
        if (!existsSync(path)) {
          options.silent === false && console.info('[NOT_EXIST]: "'.concat(path, " or ").concat(target, '" does not exist'));
          return 0;
        }
        var stat = yield promises.lstat(path);
        if (stat.isFile()) {
          target = join(target, basename(path));
          yield promises.copyFile(path, target, constants.COPYFILE_FICLONE);
          return 0;
        }
        var files = yield promises.readdir(path);
        yield Promise.all(files.map(function(name) {
          var _stat = lstatSync(join(path, name));
          return cp(join(path, name), _stat.isDirectory() ? join(target, name) : target, options);
        }));
      }, _ret;
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        _ret = yield* __yieldStar$1(_loop());
        if (_ret === 0)
          continue;
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  });
  return _cp.apply(this, arguments);
}
function cpSync(paths, target) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    silent: true,
    force: true
  };
  if (!(paths instanceof Array))
    paths = [].concat(paths);
  if (!existsSync(target))
    mkdirSync(target);
  var _iterator = _createForOfIteratorHelper(paths), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var path = _step.value;
      if (!existsSync(path)) {
        options.silent === false && console.info('[NOT_EXIST]: "'.concat(path, " or ").concat(target, '" does not exist'));
        continue;
      }
      var stat = lstatSync(path);
      if (stat.isFile()) {
        target = join(target, basename(path));
        copyFileSync(path, target, constants.COPYFILE_FICLONE);
        continue;
      }
      var files = readdirSync(path);
      var _iterator2 = _createForOfIteratorHelper(files), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var name = _step2.value;
          var _stat = lstatSync(join(path, name));
          cpSync(join(path, name), _stat.isDirectory() ? join(target, name) : target, options);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

var __knownSymbol = (name, symbol) => {
  if (symbol = Symbol[name])
    return symbol;
  throw Error("Symbol." + name + " is not defined");
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
function rm(_x) {
  return _rm.apply(this, arguments);
}
function _rm() {
  _rm = _asyncToGenerator(function* (paths) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      silent: true,
      force: true
    };
    if (!(paths instanceof Array))
      paths = [].concat(paths);
    var _iterator2 = _createForOfIteratorHelper(paths), _step2;
    try {
      var _loop2 = function* _loop22() {
        var path = _step2.value;
        typeof path === "string" && !isAbsolute(path) && (path = join(process.cwd(), path));
        if (!existsSync(path)) {
          options.silent === false && console.info('[NOT_EXIST]: "'.concat(path, '" does not exist'));
          return 0;
        }
        var stat = yield promises.lstat(path);
        if (stat.isFile()) {
          yield promises.unlink(path);
          return 0;
        }
        var files = yield promises.readdir(path);
        yield rm(files.map(function(name) {
          return typeof path === "string" ? join(path, name) : name;
        }), options);
        yield promises.rmdir(path, options);
      }, _ret2;
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        _ret2 = yield* __yieldStar(_loop2());
        if (_ret2 === 0)
          continue;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  });
  return _rm.apply(this, arguments);
}
function rmSync(paths) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    silent: true,
    force: true
  };
  if (!(paths instanceof Array))
    paths = [].concat(paths);
  var _iterator = _createForOfIteratorHelper(paths), _step;
  try {
    var _loop = function _loop2() {
      var path = _step.value;
      typeof path === "string" && !isAbsolute(path) && (path = join(process.cwd(), path));
      if (!existsSync(path)) {
        options.silent === false && console.info('[NOT_EXIST]: "'.concat(path, '" does not exist'));
        return 0;
      }
      var stat = lstatSync(path);
      if (stat.isFile()) {
        unlinkSync(path);
        return 0;
      }
      var files = readdirSync(path);
      rmSync(files.map(function(name) {
        return typeof path === "string" ? join(path, name) : name;
      }), options);
      rmdirSync(path, options);
    }, _ret;
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _ret = _loop();
      if (_ret === 0)
        continue;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function mv(_x, _x2) {
  return _mv.apply(this, arguments);
}
function _mv() {
  _mv = _asyncToGenerator(function* (paths, target) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      silent: true,
      force: true
    };
    yield cp(paths, target, options);
    yield rm(paths, options);
  });
  return _mv.apply(this, arguments);
}
function mvSync(paths, target) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    silent: true,
    force: true
  };
  cpSync(paths, target, options);
  rmSync(paths, options);
}

export { cp, cpSync, getRealPath, getRealPathSync, mv, mvSync, readJSON, readJSONSync, rm, rmSync, writeJSON, writeJSONSync };
